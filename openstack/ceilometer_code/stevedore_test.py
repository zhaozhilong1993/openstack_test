#!/usr/bin/env python
# encoding=utf-8
from stevedore import named
from ceilometer import keystone_client
import socket
from oslo_config import cfg
import pbr.version
import sys


# 模拟collect启动过程
version_info = pbr.version.VersionInfo('ceilometer')

argv = sys.argv[1:]
CONF = cfg.CONF
config_files = None

cfg.CONF(argv[1:], project='ceilometer', validate_default_values=True,
         version=version_info.version_string(),
         default_config_files=config_files)

# 模拟ceilometer-collector和gnocchi注册过程


OPTS = [
    cfg.StrOpt('host',
               default=socket.gethostname(),
               help='Name of this node, which must be valid in an AMQP '
               'key. Can be an opaque identifier. For ZeroMQ only, must '
               'be a valid host name, FQDN, or IP address.'),
    cfg.IntOpt('http_timeout',
               default=600,
               help='Timeout seconds for HTTP requests. Set it to None to '
                    'disable timeout.'),
]
cfg.CONF.register_opts(OPTS)

API_OPT = cfg.IntOpt('workers',
                     default=1,
                     min=1,
                     deprecated_group='DEFAULT',
                     deprecated_name='api_workers',
                     help='Number of workers for api, default value is 1.')
cfg.CONF.register_opt(API_OPT, 'api')

NOTI_OPT = cfg.IntOpt('workers',
                      default=1,
                      min=1,
                      deprecated_group='DEFAULT',
                      deprecated_name='notification_workers',
                      help='Number of workers for notification service, '
                           'default value is 1.')
cfg.CONF.register_opt(NOTI_OPT, 'notification')

COLL_OPT = cfg.IntOpt('workers',
                      default=1,
                      min=1,
                      deprecated_group='DEFAULT',
                      deprecated_name='collector_workers',
                      help='Number of workers for collector service. '
                           'default value is 1.')
cfg.CONF.register_opt(COLL_OPT, 'collector')

keystone_client.register_keystoneauth_opts(cfg.CONF)

# gnocchi注册
dispatcher_opts = [
    cfg.BoolOpt('filter_service_activity',
                default=True,
                help='Filter out samples generated by Gnocchi '
                'service activity'),
    cfg.StrOpt('filter_project',
               default='gnocchi',
               help='Gnocchi project used to filter out samples '
               'generated by Gnocchi service activity'),
    cfg.StrOpt('url',
               deprecated_for_removal=True,
               help='URL to Gnocchi. default: autodetection'),
    cfg.StrOpt('archive_policy',
               default=None,
               help='The archive policy to use when the dispatcher '
               'create a new metric.'),
    cfg.StrOpt('resources_definition_file',
               default='gnocchi_resources.yaml'),
]

cfg.CONF.register_opts(dispatcher_opts, group="dispatcher_gnocchi")


# 注册其他参数
OPTS = [
    cfg.MultiStrOpt('meter_dispatchers',
                    deprecated_name='dispatcher',
                    default=['database'],
                    help='Dispatchers to process metering data.'),
    cfg.MultiStrOpt('event_dispatchers',
                    default=['database'],
                    deprecated_name='dispatcher',
                    help='Dispatchers to process event data.'),
]
cfg.CONF.register_opts(OPTS)


# 模拟gnocchi的载入过程
dispatcher_type = 'meter'


def _load_dispatcher_manager(dispatcher_type):
    namespace = 'ceilometer.dispatcher.%s' % dispatcher_type
    conf_name = '%s_dispatchers' % dispatcher_type

    dispatcher_manager = named.NamedExtensionManager(
        namespace=namespace,
        names=getattr(cfg.CONF, conf_name),
        invoke_on_load=True,
        invoke_args=[cfg.CONF],
        propagate_map_exceptions=True)

    return dispatcher_manager

print getattr(cfg.CONF, 'meter_dispatchers'),
meter_manager = _load_dispatcher_manager(dispatcher_type)
sample = ''
# meter_manager.map_method('record_metering_data',sample)
print meter_manager.gnocchi

